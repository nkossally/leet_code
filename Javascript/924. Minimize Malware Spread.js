/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function (graph, initial) {
    initial.sort( (a, b) => a - b)
    const allNodes = new Array(graph.length).fill(0).map((elem, i) => i)

    const parents = [...allNodes]

    const find = i => {
        if (i !== parents[i]) {
            parents[i] = find(parents[i])
        }
        return parents[i]
    }


    const union = (i, j) => {
        parents[find(i)] = find(j)
    }

    for (let i = 0; i < graph.length; i++) {
        for (let j = i + 1; j < graph.length; j++) {
            if (graph[i][j] === 1) {
                union(i, j)
            }
        }
    }

    console.log("parents", parents)
    const area = {}
    const malware = {}

    let bestCount = -1 / 0
    let result = initial[0]

    for (let i = 0; i < graph.length; i++) {
        const val = find(i)
        if (!area[val]) area[val] = 0
        area[val]++
    }

    for (let i = 0; i < initial.length; i++) {
        const val = find(initial[i])
        if (!malware[val]) malware[val] = 0
        malware[val]++
    }

    for (let i = 0; i < initial.length; i++) {
        const node = initial[i]
        if (malware[find(node)] === 1) {
            if (area[find(node)] > bestCount) {
                result = node
                bestCount = area[find(node)]
            } else if (area[find(node)] === bestCount) {
                result = Math.min(result, node)
            }
        }
    }

    return result
};

/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpreadSlow = function (graph, initial) {
    const nodes = new Set()
    const initialSet = new Set(initial)
    for (let i = 0; i < graph.length; i++) {
        nodes.add(i)
    }

    let chosenNode
    let brestNodeCount = -1 / 0
    const nodeToConnections = []

    const getAllConnectedNodes = (node) => {
        const connections = new Set()

        const addDirectConnections = currNode => {
            connections.add(currNode)

            const directConnections = graph[currNode]
            for(let i = 0; i < graph[currNode].length; i++){
                if(graph[currNode][i] === 1 && !connections.has(i)){
                    if(initialSet.has(node) && i > node){
                        initialSet.delete(i)
                    }
                    addDirectConnections(i)
                }
            }

        }
        addDirectConnections(node)
        nodeToConnections[node] = connections
    }

    for (let i = 0; i < graph.length; i++) {
        getAllConnectedNodes(i)
    }

    const getStateAfterRemovingInfectedNode = (removedNode) => {
        const nodesDup = new Set(Array.from(nodes))
        for (let i = 0; i < initial.length; i++) {
            const infectedNode = initial[i]
            if (infectedNode !== removedNode) {
                const connections = nodeToConnections[infectedNode]
                connections.forEach(adjacentNode => {
                    nodesDup.delete(adjacentNode)
                })
            }
        }

        if (chosenNode === undefined || nodesDup.size > bestNodeCount || (bestNodeCount === nodesDup.size && removedNode < chosenNode)) {
            chosenNode = removedNode
            bestNodeCount = nodesDup.size
        }

    }

    const initialArr = Array.from(initialSet)
    if(initialArr.length === 1) return initialArr[0]


    for (let i = 0; i < initialArr.length; i++) {
        getStateAfterRemovingInfectedNode(initialArr[i])
    }

    return chosenNode
};